{"version":3,"sources":["../node_modules/crc-32/crc32.js","../node_modules/png-chunks-extract/index.js","../node_modules/png-chunk-text/index.js","../node_modules/png-chunk-text/encode.js","../node_modules/png-chunk-text/decode.js","../node_modules/png-chunks-encode/index.js","../node_modules/sliced/index.js","data/image.ts"],"names":["factory","CRC32","version","table","c","Array","n","Int32Array","signed_crc_table","use_buffer","Buffer","crc32_buf_8","buf","crc","i","L","length","bstr","charCodeAt","str","d","DO_NOT_EXPORT_CRC","exports","crc32","require","module","data","Error","ended","chunks","idx","uint8","uint32","chunk","Uint8Array","name","String","fromCharCode","push","crcActual","int32","chunkData","buffer","slice","Uint32Array","encode","decode","keyword","content","test","code","totalSize","output","j","naming","text","sliced","size","nameChars","crcCheck","concat","args","sliceEnd","ret","len","start","Math","max","undefined","blobToArrayBuffer","blob","arrayBuffer","Promise","resolve","reject","reader","FileReader","onload","event","target","result","readAsArrayBuffer","getTEXtChunk","a","decodePng","metadataChunk","find","tEXt","encodePngMetadata","metadata","MIME_TYPES","excalidraw","JSON","compress","stringify","splice","Blob","encodePng","type","png","decodePngMetadata","encodedData","parse","EXPORT_DATA_TYPES","console","error","encodeSvgMetadata","stringToBase64","base64","decodeSvgMetadata","svg","includes","match","versionMatch","isByteString","base64ToString","json"],"mappings":"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","file":"static/js/image.a4081b0a.chunk.js","sourcesContent":["/* crc32.js (C) 2014-2015 SheetJS -- http://sheetjs.com */\n/* vim: set ts=2: */\nvar CRC32;\n(function (factory) {\n\tif(typeof DO_NOT_EXPORT_CRC === 'undefined') {\n\t\tif('object' === typeof exports) {\n\t\t\tfactory(exports);\n\t\t} else if ('function' === typeof define && define.amd) {\n\t\t\tdefine(function () {\n\t\t\t\tvar module = {};\n\t\t\t\tfactory(module);\n\t\t\t\treturn module;\n\t\t\t});\n\t\t} else {\n\t\t  factory(CRC32 = {});\n\t\t}\n\t} else {\n\t\tfactory(CRC32 = {});\n\t}\n}(function(CRC32) {\nCRC32.version = '0.3.0';\n/* see perf/crc32table.js */\nfunction signed_crc_table() {\n\tvar c = 0, table = new Array(256);\n\n\tfor(var n =0; n != 256; ++n){\n\t\tc = n;\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\tc = ((c&1) ? (-306674912 ^ (c >>> 1)) : (c >>> 1));\n\t\ttable[n] = c;\n\t}\n\n\treturn typeof Int32Array !== 'undefined' ? new Int32Array(table) : table;\n}\n\nvar table = signed_crc_table();\n/* charCodeAt is the best approach for binary strings */\nvar use_buffer = typeof Buffer !== 'undefined';\nfunction crc32_bstr(bstr) {\n\tif(bstr.length > 32768) if(use_buffer) return crc32_buf_8(new Buffer(bstr));\n\tvar crc = -1, L = bstr.length - 1;\n\tfor(var i = 0; i < L;) {\n\t\tcrc =  table[(crc ^ bstr.charCodeAt(i++)) & 0xFF] ^ (crc >>> 8);\n\t\tcrc =  table[(crc ^ bstr.charCodeAt(i++)) & 0xFF] ^ (crc >>> 8);\n\t}\n\tif(i === L) crc = (crc >>> 8) ^ table[(crc ^ bstr.charCodeAt(i)) & 0xFF];\n\treturn crc ^ -1;\n}\n\nfunction crc32_buf(buf) {\n\tif(buf.length > 10000) return crc32_buf_8(buf);\n\tfor(var crc = -1, i = 0, L=buf.length-3; i < L;) {\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t}\n\twhile(i < L+3) crc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\treturn crc ^ -1;\n}\n\nfunction crc32_buf_8(buf) {\n\tfor(var crc = -1, i = 0, L=buf.length-7; i < L;) {\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t\tcrc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\t}\n\twhile(i < L+7) crc = (crc >>> 8) ^ table[(crc^buf[i++])&0xFF];\n\treturn crc ^ -1;\n}\n\n/* much much faster to intertwine utf8 and crc */\nfunction crc32_str(str) {\n\tfor(var crc = -1, i = 0, L=str.length, c, d; i < L;) {\n\t\tc = str.charCodeAt(i++);\n\t\tif(c < 0x80) {\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ c) & 0xFF];\n\t\t} else if(c < 0x800) {\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (192|((c>>6)&31))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|(c&63))) & 0xFF];\n\t\t} else if(c >= 0xD800 && c < 0xE000) {\n\t\t\tc = (c&1023)+64; d = str.charCodeAt(i++) & 1023;\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (240|((c>>8)&7))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|((c>>2)&63))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|((d>>6)&15)|(c&3))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|(d&63))) & 0xFF];\n\t\t} else {\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (224|((c>>12)&15))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|((c>>6)&63))) & 0xFF];\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ (128|(c&63))) & 0xFF];\n\t\t}\n\t}\n\treturn crc ^ -1;\n}\nCRC32.table = table;\nCRC32.bstr = crc32_bstr;\nCRC32.buf = crc32_buf;\nCRC32.str = crc32_str;\n}));\n","var crc32 = require('crc-32')\n\nmodule.exports = extractChunks\n\n// Used for fast-ish conversion between uint8s and uint32s/int32s.\n// Also required in order to remain agnostic for both Node Buffers and\n// Uint8Arrays.\nvar uint8 = new Uint8Array(4)\nvar int32 = new Int32Array(uint8.buffer)\nvar uint32 = new Uint32Array(uint8.buffer)\n\nfunction extractChunks (data) {\n  if (data[0] !== 0x89) throw new Error('Invalid .png file header')\n  if (data[1] !== 0x50) throw new Error('Invalid .png file header')\n  if (data[2] !== 0x4E) throw new Error('Invalid .png file header')\n  if (data[3] !== 0x47) throw new Error('Invalid .png file header')\n  if (data[4] !== 0x0D) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?')\n  if (data[5] !== 0x0A) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?')\n  if (data[6] !== 0x1A) throw new Error('Invalid .png file header')\n  if (data[7] !== 0x0A) throw new Error('Invalid .png file header: possibly caused by DOS-Unix line ending conversion?')\n\n  var ended = false\n  var chunks = []\n  var idx = 8\n\n  while (idx < data.length) {\n    // Read the length of the current chunk,\n    // which is stored as a Uint32.\n    uint8[3] = data[idx++]\n    uint8[2] = data[idx++]\n    uint8[1] = data[idx++]\n    uint8[0] = data[idx++]\n\n    // Chunk includes name/type for CRC check (see below).\n    var length = uint32[0] + 4\n    var chunk = new Uint8Array(length)\n    chunk[0] = data[idx++]\n    chunk[1] = data[idx++]\n    chunk[2] = data[idx++]\n    chunk[3] = data[idx++]\n\n    // Get the name in ASCII for identification.\n    var name = (\n      String.fromCharCode(chunk[0]) +\n      String.fromCharCode(chunk[1]) +\n      String.fromCharCode(chunk[2]) +\n      String.fromCharCode(chunk[3])\n    )\n\n    // The IHDR header MUST come first.\n    if (!chunks.length && name !== 'IHDR') {\n      throw new Error('IHDR header missing')\n    }\n\n    // The IEND header marks the end of the file,\n    // so on discovering it break out of the loop.\n    if (name === 'IEND') {\n      ended = true\n      chunks.push({\n        name: name,\n        data: new Uint8Array(0)\n      })\n\n      break\n    }\n\n    // Read the contents of the chunk out of the main buffer.\n    for (var i = 4; i < length; i++) {\n      chunk[i] = data[idx++]\n    }\n\n    // Read out the CRC value for comparison.\n    // It's stored as an Int32.\n    uint8[3] = data[idx++]\n    uint8[2] = data[idx++]\n    uint8[1] = data[idx++]\n    uint8[0] = data[idx++]\n\n    var crcActual = int32[0]\n    var crcExpect = crc32.buf(chunk)\n    if (crcExpect !== crcActual) {\n      throw new Error(\n        'CRC values for ' + name + ' header do not match, PNG file is likely corrupted'\n      )\n    }\n\n    // The chunk data is now copied to remove the 4 preceding\n    // bytes used for the chunk name/type.\n    var chunkData = new Uint8Array(chunk.buffer.slice(4))\n\n    chunks.push({\n      name: name,\n      data: chunkData\n    })\n  }\n\n  if (!ended) {\n    throw new Error('.png file ended prematurely: no IEND header was found')\n  }\n\n  return chunks\n}\n","exports.encode = require('./encode')\nexports.decode = require('./decode')\n","module.exports = encode\n\nfunction encode (keyword, content) {\n  keyword = String(keyword)\n  content = String(content)\n\n  if (!/^[\\x00-\\xFF]+$/.test(keyword) || !/^[\\x00-\\xFF]+$/.test(content)) {\n    throw new Error('Only Latin-1 characters are permitted in PNG tEXt chunks. You might want to consider base64 encoding and/or zEXt compression')\n  }\n\n  if (keyword.length >= 80) {\n    throw new Error('Keyword \"' + keyword + '\" is longer than the 79-character limit imposed by the PNG specification')\n  }\n\n  var totalSize = keyword.length + content.length + 1\n  var output = new Uint8Array(totalSize)\n  var idx = 0\n  var code\n\n  for (var i = 0; i < keyword.length; i++) {\n    if (!(code = keyword.charCodeAt(i))) {\n      throw new Error('0x00 character is not permitted in tEXt keywords')\n    }\n\n    output[idx++] = code\n  }\n\n  output[idx++] = 0\n\n  for (var j = 0; j < content.length; j++) {\n    if (!(code = content.charCodeAt(j))) {\n      throw new Error('0x00 character is not permitted in tEXt content')\n    }\n\n    output[idx++] = code\n  }\n\n  return {\n    name: 'tEXt',\n    data: output\n  }\n}\n","module.exports = decode\n\nfunction decode (data) {\n  if (data.data && data.name) {\n    data = data.data\n  }\n\n  var naming = true\n  var text = ''\n  var name = ''\n\n  for (var i = 0; i < data.length; i++) {\n    var code = data[i]\n\n    if (naming) {\n      if (code) {\n        name += String.fromCharCode(code)\n      } else {\n        naming = false\n      }\n    } else {\n      if (code) {\n        text += String.fromCharCode(code)\n      } else {\n        throw new Error('Invalid NULL character found. 0x00 character is not permitted in tEXt content')\n      }\n    }\n  }\n\n  return {\n    keyword: name,\n    text: text\n  }\n}\n","var sliced = require('sliced')\nvar crc32 = require('crc-32')\n\nmodule.exports = encodeChunks\n\n// Used for fast-ish conversion between uint8s and uint32s/int32s.\n// Also required in order to remain agnostic for both Node Buffers and\n// Uint8Arrays.\nvar uint8 = new Uint8Array(4)\nvar int32 = new Int32Array(uint8.buffer)\nvar uint32 = new Uint32Array(uint8.buffer)\n\nfunction encodeChunks (chunks) {\n  var totalSize = 8\n  var idx = totalSize\n  var i\n\n  for (i = 0; i < chunks.length; i++) {\n    totalSize += chunks[i].data.length\n    totalSize += 12\n  }\n\n  var output = new Uint8Array(totalSize)\n\n  output[0] = 0x89\n  output[1] = 0x50\n  output[2] = 0x4E\n  output[3] = 0x47\n  output[4] = 0x0D\n  output[5] = 0x0A\n  output[6] = 0x1A\n  output[7] = 0x0A\n\n  for (i = 0; i < chunks.length; i++) {\n    var chunk = chunks[i]\n    var name = chunk.name\n    var data = chunk.data\n    var size = data.length\n    var nameChars = [\n      name.charCodeAt(0),\n      name.charCodeAt(1),\n      name.charCodeAt(2),\n      name.charCodeAt(3)\n    ]\n\n    uint32[0] = size\n    output[idx++] = uint8[3]\n    output[idx++] = uint8[2]\n    output[idx++] = uint8[1]\n    output[idx++] = uint8[0]\n\n    output[idx++] = nameChars[0]\n    output[idx++] = nameChars[1]\n    output[idx++] = nameChars[2]\n    output[idx++] = nameChars[3]\n\n    for (var j = 0; j < size;) {\n      output[idx++] = data[j++]\n    }\n\n    var crcCheck = nameChars.concat(sliced(data))\n    var crc = crc32.buf(crcCheck)\n\n    int32[0] = crc\n    output[idx++] = uint8[3]\n    output[idx++] = uint8[2]\n    output[idx++] = uint8[1]\n    output[idx++] = uint8[0]\n  }\n\n  return output\n}\n","\n/**\n * An Array.prototype.slice.call(arguments) alternative\n *\n * @param {Object} args something with a length\n * @param {Number} slice\n * @param {Number} sliceEnd\n * @api public\n */\n\nmodule.exports = function (args, slice, sliceEnd) {\n  var ret = [];\n  var len = args.length;\n\n  if (0 === len) return ret;\n\n  var start = slice < 0\n    ? Math.max(0, slice + len)\n    : slice || 0;\n\n  if (sliceEnd !== undefined) {\n    len = sliceEnd < 0\n      ? sliceEnd + len\n      : sliceEnd\n  }\n\n  while (len-- > start) {\n    ret[len - start] = args[len];\n  }\n\n  return ret;\n}\n\n","import decodePng from \"png-chunks-extract\";\nimport tEXt from \"png-chunk-text\";\nimport encodePng from \"png-chunks-encode\";\nimport { stringToBase64, encode, decode, base64ToString } from \"./encode\";\nimport { EXPORT_DATA_TYPES, MIME_TYPES } from \"../constants\";\n\n// -----------------------------------------------------------------------------\n// PNG\n// -----------------------------------------------------------------------------\n\nconst blobToArrayBuffer = (blob: Blob): Promise<ArrayBuffer> => {\n  if (\"arrayBuffer\" in blob) {\n    return blob.arrayBuffer();\n  }\n  // Safari\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = (event) => {\n      if (!event.target?.result) {\n        return reject(new Error(\"couldn't convert blob to ArrayBuffer\"));\n      }\n      resolve(event.target.result as ArrayBuffer);\n    };\n    reader.readAsArrayBuffer(blob);\n  });\n};\n\nexport const getTEXtChunk = async (\n  blob: Blob,\n): Promise<{ keyword: string; text: string } | null> => {\n  const chunks = decodePng(new Uint8Array(await blobToArrayBuffer(blob)));\n  const metadataChunk = chunks.find((chunk) => chunk.name === \"tEXt\");\n  if (metadataChunk) {\n    return tEXt.decode(metadataChunk.data);\n  }\n  return null;\n};\n\nexport const encodePngMetadata = async ({\n  blob,\n  metadata,\n}: {\n  blob: Blob;\n  metadata: string;\n}) => {\n  const chunks = decodePng(new Uint8Array(await blobToArrayBuffer(blob)));\n\n  const metadataChunk = tEXt.encode(\n    MIME_TYPES.excalidraw,\n    JSON.stringify(\n      await encode({\n        text: metadata,\n        compress: true,\n      }),\n    ),\n  );\n  // insert metadata before last chunk (iEND)\n  chunks.splice(-1, 0, metadataChunk);\n\n  return new Blob([encodePng(chunks)], { type: MIME_TYPES.png });\n};\n\nexport const decodePngMetadata = async (blob: Blob) => {\n  const metadata = await getTEXtChunk(blob);\n  if (metadata?.keyword === MIME_TYPES.excalidraw) {\n    try {\n      const encodedData = JSON.parse(metadata.text);\n      if (!(\"encoded\" in encodedData)) {\n        // legacy, un-encoded scene JSON\n        if (\n          \"type\" in encodedData &&\n          encodedData.type === EXPORT_DATA_TYPES.excalidraw\n        ) {\n          return metadata.text;\n        }\n        throw new Error(\"FAILED\");\n      }\n      return await decode(encodedData);\n    } catch (error: any) {\n      console.error(error);\n      throw new Error(\"FAILED\");\n    }\n  }\n  throw new Error(\"INVALID\");\n};\n\n// -----------------------------------------------------------------------------\n// SVG\n// -----------------------------------------------------------------------------\n\nexport const encodeSvgMetadata = async ({ text }: { text: string }) => {\n  const base64 = await stringToBase64(\n    JSON.stringify(await encode({ text })),\n    true /* is already byte string */,\n  );\n\n  let metadata = \"\";\n  metadata += `<!-- payload-type:${MIME_TYPES.excalidraw} -->`;\n  metadata += `<!-- payload-version:2 -->`;\n  metadata += \"<!-- payload-start -->\";\n  metadata += base64;\n  metadata += \"<!-- payload-end -->\";\n  return metadata;\n};\n\nexport const decodeSvgMetadata = async ({ svg }: { svg: string }) => {\n  if (svg.includes(`payload-type:${MIME_TYPES.excalidraw}`)) {\n    const match = svg.match(/<!-- payload-start -->(.+?)<!-- payload-end -->/);\n    if (!match) {\n      throw new Error(\"INVALID\");\n    }\n    const versionMatch = svg.match(/<!-- payload-version:(\\d+) -->/);\n    const version = versionMatch?.[1] || \"1\";\n    const isByteString = version !== \"1\";\n\n    try {\n      const json = await base64ToString(match[1], isByteString);\n      const encodedData = JSON.parse(json);\n      if (!(\"encoded\" in encodedData)) {\n        // legacy, un-encoded scene JSON\n        if (\n          \"type\" in encodedData &&\n          encodedData.type === EXPORT_DATA_TYPES.excalidraw\n        ) {\n          return json;\n        }\n        throw new Error(\"FAILED\");\n      }\n      return await decode(encodedData);\n    } catch (error: any) {\n      console.error(error);\n      throw new Error(\"FAILED\");\n    }\n  }\n  throw new Error(\"INVALID\");\n};\n"],"sourceRoot":""}